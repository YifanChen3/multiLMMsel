% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/algorithm.R
\name{multiLMMsel}
\alias{multiLMMsel}
\title{Variable Selection for Multivariate Mixed-Effects Models (multiLMMsel)}
\usage{
multiLMMsel(
  Y,
  Z,
  X,
  lambdas,
  tau,
  threshold = 0.01,
  gamma = 2,
  gamma.weight = 2,
  eta = NULL,
  d = NULL,
  p = NULL,
  q = NULL,
  id,
  deltaB = 0,
  deltaE = 1e-04,
  max.iter = 1,
  tol = 0.01,
  max.iterB = 1000,
  tolB = 1e-08,
  sigmaB = NULL,
  beta = NULL,
  y.dbsum = NULL,
  ww.trisum = NULL,
  y.trisum = NULL,
  ww.trisum.d = NULL,
  y.trisum.d = NULL,
  bootstrap.iter = 30
)
}
\arguments{
\item{Y}{Numeric matrix of responses of size \code{N x d}.}

\item{Z}{Random-effects design matrix of size \code{N x q}.}

\item{X}{Fixed-effects design matrix of size \code{N x p}.}

\item{lambdas}{Numeric vector of length \code{d} giving the penalty level
for each response dimension.}

\item{tau}{Regularization parameter for the adaptive lasso step in the
fixed-effects update.}

\item{threshold}{Threshold on the diagonal of \code{Sigma_B} used to define
the active set of random effects.}

\item{gamma}{Noise variance parameter used in the bootstrap-based beta
updating scheme.}

\item{gamma.weight}{Power used in the adaptive weights for the diagonal of
\code{Sigma_B}.}

\item{eta}{Step size for the proximal-gradient update of \code{Sigma_B}.
If \code{NULL}, it is chosen theoretically from the largest eigenvalue of the Hessian.}

\item{d}{Number of responses. If \code{NULL}, taken as \code{ncol(Y)}.}

\item{p}{Number of fixed effects. If \code{NULL}, taken as \code{ncol(X)}.}

\item{q}{Number of random effects per response. If \code{NULL}, inferred
from \code{ncol(Z)}.}

\item{id}{Integer or factor vector of length \code{N} giving the subject or
cluster index for each row of \code{Y}, \code{X}, and \code{Z}.}

\item{deltaB}{Eigenvalue threshold for the projection of \code{Sigma_B} onto PSD cone.}

\item{deltaE}{Eigenvalue threshold for the projection of \code{Sigma_E} onto PSD cone.}

\item{max.iter}{Maximum number of outer iterations.}

\item{tol}{Convergence tolerance outer iterations.}

\item{max.iterB}{Maximum number of inner iterations for \code{Sigma_B}
updates.}

\item{tolB}{Convergence tolerance for inner \code{Sigma_B} updates.}

\item{sigmaB}{Optional initial value for \code{Sigma_B}.}

\item{beta}{Optional initial value for the fixed effects matrix \code{beta}.}

\item{y.dbsum, ww.trisum, y.trisum, ww.trisum.d, y.trisum.d}{Optional
precomputed quantities (typically produced by C++ helper
functions) to avoid recomputation.}

\item{bootstrap.iter}{Number of bootstrap iterations used in the fixed-effect
update.}
}
\value{
A list with components:
\item{SigmaB}{Estimated random-effects covariance matrix.}
\item{SigmaE}{Estimated residual covariance matrix.}
\item{beta}{Estimated fixed-effects coefficient matrix.}
\item{iterB}{Number of iterations for SigmaB updates.}
}
\description{
Fit a multivariate high-dimensional mixed-effects model with variable
selection using the proposed moment-based convex optimization algorithm.
}
\details{
The function performs five-step updates of the random-effects covariance
\eqn{\Sigma_B}, the residual covariance \eqn{\Sigma_\varepsilon}, and the
fixed effects \eqn{\beta}, given user-specified regularization parameters
\code{lambdas} and \code{tau}.
}
\examples{
\dontrun{
set.seed(1234)
d <- 3
q <- 5
dq <- d*q
p <- 10
m <- 50
ni <- 6
s <- 3
rho <- 0.5
M <- bdiag(toeplitz(rho^seq(0, s-1)),matrix(0,q-s,q-s))
R <- cbind(M,M,M)
sigmaB <- rbind(R,R,R)
rho <- 0.75
sigmaE <- toeplitz(rho^seq(0, d - 1))
id <- rep(1:m,each=ni)
m <- length(unique(id)) # Number of subjects (groups)
N <- length(id) # Total number of observations
epsilon <- mvrnorm(N,rep(0,d),sigmaE)
vecB <- mvrnorm(m,rep(0,dq),sigmaB)
B <- do.call(rbind,lapply(1:nrow(vecB), function(i) {
  matrix(vecB[i, ], nrow = q, ncol = d, byrow = FALSE)
}))
Z <- matrix(rnorm(N*q),nrow = N,ncol = q)
X <- matrix(rnorm(N*p),nrow = N,ncol = p)
beta <- matrix(c(1,-1,2,rep(0,7),-1,2,-1,rep(0,7),1,1,2,rep(0,7)),nrow = p,ncol = d)
Z_list <- lapply(split(seq_len(nrow(Z)), id),
                 function(idx) Z[idx, , drop = FALSE])
Z_long <- bdiag(lapply(Z_list, as.matrix))
Y <- X \%*\% beta + as.matrix(Z_long) \%*\% B + epsilon

lambdas <- c(200,200,200)
tau <- 0.2
result <- multiLMMsel(Y,Z,X,lambdas,tau,id = id)
}

}
